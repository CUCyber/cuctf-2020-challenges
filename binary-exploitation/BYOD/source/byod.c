#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/mutex.h>
#include <linux/slab.h>

#define DEVICE_NAME "byod"
#define CLASS_NAME  "byod"

MODULE_AUTHOR("Nick Bulischeck");
MODULE_DESCRIPTION("Our new BYOD policy! You can have at most one device at a time.");
MODULE_LICENSE("GPL");

static DEFINE_MUTEX(dev_lock);
static DEFINE_MUTEX(dev_ioctl_lock);

struct request {
	unsigned long length;
	unsigned long handle;
};

struct example_device {
	bool allocated;
	char *data;
} device = {false, NULL};

static int major;
static struct class  *char_class  = NULL;
static struct device *char_device = NULL;

static inline int dev_open(struct inode *inodep, struct file *filep){
	if (!mutex_trylock(&dev_lock)){
		return -EBUSY;
	}
	return 0;
}

static inline long dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg){
	int i;
	struct request *req = NULL;

	if (!mutex_trylock(&dev_ioctl_lock)){
		return -EBUSY;
	}

	switch (cmd){
	case 0x1000:
		if (device.allocated){
			mutex_unlock(&dev_ioctl_lock);
			return -EINVAL;
		}
		device.data = kmalloc(0x20, GFP_KERNEL);
		if (!device.data){
			mutex_unlock(&dev_ioctl_lock);
			return -ENOMEM;
		}
		device.allocated = true;
		break;
	case 0x1001:
		req = (struct request *)arg;
		if (req->length > 0x20){
			mutex_unlock(&dev_ioctl_lock);
			return -EINVAL;
		}
		for (i = 0; i < req->length; i++){
			((char *)req->handle)[i] = device.data[i];
		}
		break;
	case 0x1002:
		req = (struct request *)arg;
		if (!device.allocated){
			break;
		}
		if (req->length > 0x28){
			mutex_unlock(&dev_ioctl_lock);
			return -EINVAL;
		}
		for (i = 0; i < req->length; i++){
			device.data[i] = ((char *)req->handle)[i];
		}
		break;
	case 0x1003:
		if (!device.allocated){
			break;
		}
		device.allocated = false;
		kfree(device.data);
		break;
	default:
		mutex_unlock(&dev_ioctl_lock);
		return -EINVAL;
	}

	mutex_unlock(&dev_ioctl_lock);
	return 0;
}

static inline ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset){
	return -ENOSYS;
}

static inline ssize_t dev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset){
	return -ENOSYS;
}

static inline int dev_release(struct inode *inodep, struct file *filep){
	mutex_unlock(&dev_lock);
	return 0;
}

static struct file_operations fops = {
	.owner = THIS_MODULE,
	.open = dev_open,
	.read = dev_read,
	.write = dev_write,
	.release = dev_release,
	.unlocked_ioctl = dev_ioctl,
};

void exit_char_dev(void){
	device_destroy(char_class, MKDEV(major, 0));
	class_unregister(char_class);
	class_destroy(char_class);
	unregister_chrdev(major, DEVICE_NAME);
}

static char *set_mode_devnode(struct device *dev, umode_t *mode){
	if (mode)
		*mode = 0666;
	return NULL;
}

int init_char_dev(void){
	major = register_chrdev(0, DEVICE_NAME, &fops);
	if (major < 0){
		return major;
	}

	char_class = class_create(NULL, CLASS_NAME);
	if (IS_ERR(char_class)){
		unregister_chrdev(major, DEVICE_NAME);
		return PTR_ERR(char_class);
	}

	char_class->devnode = set_mode_devnode;

	char_device = device_create(char_class, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);
	if (IS_ERR(char_device)){
		class_destroy(char_class);
		unregister_chrdev(major, DEVICE_NAME);
		return PTR_ERR(char_device);
	}
	return 0;
}

static int __init init_mod(void){
	mutex_init(&dev_lock);
	mutex_init(&dev_ioctl_lock);
	if (init_char_dev() < 0)
	{
		return -1;
	}
	printk(KERN_INFO "BYOD: Initialized module\n");
	return 0;
}

static void __exit exit_mod(void){
	exit_char_dev();
	mutex_destroy(&dev_ioctl_lock);
	mutex_destroy(&dev_lock);
	printk(KERN_INFO "BYOD: Module removed\n");
}

module_init(init_mod);
module_exit(exit_mod);
